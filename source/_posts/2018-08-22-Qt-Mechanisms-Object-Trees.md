---
title: 'Qt从0到1之机制篇 - 对象树'
author: 张帆
tags:
  - Qt
  - Qt从0到1
  - Qt机制
date: 2018-08-22 16:29:43
---

C/C++一直为人诟病的一点就是内存管理，C/C++提供了直接的内存操作接口给用户，这虽然效率上的优势，但也带来了内存泄漏等问题。虽然C++中引入了智能指针，但这对于管理一个GUI程序来说，一个控件中可能包含多个子控件，子控件也可能包含多个子控件，控件上可能还包含一些不可见对象，当一个控件被删除后，附在其上的子控件和不可见对象也需要一并删除，智能指针也难以实现这样的效果。因此Qt引入了对象树系统。

## 认识对象树

对象树指的是Qt中树状的管理对象的所有权的一套机制，主要是为了解决对象的生命周期管理问题。其有以下特点：
- 在对象树中，每个节点都是一个QObject或其子类对象。
- - 父节点拥有子节点的所有权，即父节点被删除时，子节点也会被删除。
- 子节点会继承父节点的部分效果。如父节点隐藏时，子节点也回被隐藏；为父节点设置的QSS效果也会影响到子节点。
- 对于类型为`QWidget`或`QWidget`之类的子节点，其布局坐标系是相对于父节点的。即子控件的坐标系是相对于父控件的。

## 使用对象树

``` cpp
QObject(QObject *parent = Q_NULLPTR)
```
这是`QObject`的构造函数，我们可以看到有一个参数`parent`，这个参数就是用于指定该对象的父节点。所有继承于`QObject`的类，其构造函数中都存在这个参数。特别的，对于`QWidget`及其子类等可见控件，`parent`参数的类型为`QWidget`。
`parent`参数有一个默认参数`Q_NULLPTR`，这是一个Qt定义的宏，在`nullptr`引入C++11之前Qt就提供了这个宏用于表示空指针。若一个节点的父节点为空，则其为顶层节点。对于类型为`QWidget`及其子类的节点，若其为一个顶层节点，则其以桌面为坐标系进行布局。

## 理解对象树

对象树的实现依赖`QObject`。`QObject`内部保存了其子节点的一个列表，我们可以通过`QList<QObject *> QObject::children()`方法获取其保存的子节点列表。同时，`QObject`也保存了其父节点的指针。当一个节点被删除时，其会遍历子节点列表，将子节点也一并删除，从而实现一个树状的链式删除。除了删除子节点，为了避免其父节点在删除时又重复析构自己，一个节点删除时还会将自己从其父节点的子节点列表中移除。我们看一个例子。
``` cpp
#include <QApplication>
#include <QTimer>
#include <QWidget>

int main(int argc, char *argv[]) {
    QApplication a(argc, argv);

    QTimer timer;
    QWidget w;
    timer.setParent(&w);

    w.show();

    return a.exec();
}
```
执行这个程序，退出时输出窗口会打印以下信息

> double free or corruption (out)
> 20:47:14: 程序异常结束。



## 注意点

1. 对象树
